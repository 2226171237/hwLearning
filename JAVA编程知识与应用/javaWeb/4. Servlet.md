# Servlet

## 简介

Servlet 是SUN公司开发动态web的一门技术，在这些api中提供了一个接口叫Servlet。只需完成两个小步骤：

* 编写一个类，实现Servlet接口
* 把开发好的java类部署到web服务器中。

把实现了Servlet接口的java程序叫做Servlet。

## Hello Servlet

Servlet在sun公司又两个默认实现的接口类：HttpServlet

1. 使用Maven建一个空项目，然后删除src目录，以后我们的学习就在这个项目里建立module，这个空工程就是maven的主工程。
2. 关于Maven父子工程的理解：父项目中pom.xml包含子项目

```xml
<modules>
   <module>servlet-01</module>
</modules>
```

子项目中会有

```xml
<parent>
    <artifactId>helloservlet</artifactId>
    <groupId>org.example</groupId>
    <version>1.0-SNAPSHOT</version>
</parent>
```

父项目中的java，子项目可以直接使用。

```java
son extends father
```

3.  maven环境优化

4. 编写一个servlet程序

   ```java
   public class HelloServlet extends HttpServlet {
       // 哟与get或post只是请求实现的不同方式，可以相互调用，业务逻辑都一样
       @Override
       protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
           PrintWriter writer=resp.getWriter(); // 响应流
           writer.print("Hello Servlet");
   
       }
   
       @Override
       protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
           doGet(req,resp);
       }
   }
   ```

5. 编写Servlet的映射

   我们写的是java程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要在web服务器中注册我们写的Servlet，还需给他一个浏览器能够的路径。

   ```xml
   file: web.xml中
   <!--注册servlet-->
     <servlet>
       <servlet-name>hello</servlet-name>
       <servlet-class>com.liyajie.servlet.HelloServlet</servlet-class>
     </servlet>
   
     <!--servlet请求路径-->
     <servlet-mapping>
       <servlet-name>hello</servlet-name>
       <url-pattern>/hello</url-pattern>
     </servlet-mapping>
   ```

   

6. 配置tomcat

7. 启动测试

## Servlet原理

Servlet是由Web服务器调用，web服务器在收到浏览器请求后，会：

<img src="../imgs/image-20210329161408415.png" alt="image-20210329161408415" style="zoom:80%;" />

## Mapping

1. 一个Servlet可以指定一个映射路径

   ```xml
   <servlet-mapping>
       <servlet-name>hello</servlet-name>
       <url-pattern>/hello</url-pattern>
     </servlet-mapping>
   ```

2. 一个Servlet可以指定多个映射路径

   ```xml
   <servlet-mapping>
       <servlet-name>hello</servlet-name>
       <url-pattern>/hello1</url-pattern>
     </servlet-mapping>
   <servlet-mapping>
       <servlet-name>hello</servlet-name>
       <url-pattern>/hello2</url-pattern>
     </servlet-mapping>
   <servlet-mapping>
       <servlet-name>hello</servlet-name>
       <url-pattern>/hello3</url-pattern>
     </servlet-mapping>
   ```

3. 一个Servlet可以指定通用的映射路径，使用通配符 " * " 。

   ```xml
   <servlet-mapping>
       <servlet-name>hello</servlet-name>
       <url-pattern>/hello/*</url-pattern>
     </servlet-mapping>
   ```

4. 或加其他

   ```xml
   <servlet-mapping>
       <servlet-name>hello</servlet-name>
       <url-pattern>*.do</url-pattern>  // 自定义后缀实现 *前面不能加映射的路径（如：/hello/*.do）
     </servlet-mapping>
   ```

5.  优先级问题

   通配符的优先级最低。

## ServletContext

web容器在启动时，它会为每个web程序都创建一个对应的ServletContext对象，它代表当前的web应用（类似PCB）。

* 共享数据 （不同的Servlet程序都可以使用），可实现不同servlet之间通信。(不同Servlet对象共享同一个context)

  <img src="../imgs/image-20210329171408966.png" alt="image-20210329171408966" style="zoom:80%;" />

  ```java
  public class HelloServlet  extends HttpServlet {
      @Override
      protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          ServletContext context=this.getServletContext();
          String userName="Liyajie";
          context.setAttribute("userName",userName);  // 发送数据
      }
  
      @Override
      protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          doGet(req,resp);
      }
  }
  
  public class GetServlet extends HttpServlet {
  
      @Override
      protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          ServletContext context=this.getServletContext();
          String usrName=(String) context.getAttribute("userName");  // 获取数据
          System.out.println(usrName);
      }
  
      @Override
      protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          doGet(req, resp);
      }
  }
  ```

  

* 

