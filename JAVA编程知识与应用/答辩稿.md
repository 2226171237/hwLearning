1. 各位领导下午好，我叫李亚杰，是毕业于中科大的应届生，来自综合服务域，我的导师是孙振兴，下面我将开始我的转正答辩。

2. 在四个月的工作中，我首席按完成了部门的新员工培训，和基础知识的学习，并完成应用管理的web应用链接测试，SSO新服务开发对接三方eSight，以及应用管理的OS同步操作的重构工作的三个需求的开发工作。在功能工作方面，我负责了SSO服务的API Test维护，UT用例的维护，以及SSO的手工测试用例设计与编写，和SSO的安全排查工作。同时现在通过了可信认证工作级，专业级通过了科目一和科目二。

3. 下面我将介绍我的主要工作内容：

4. 首先刚来第一个月，完成了一个WEB应用链接测试的需求，这个工作主要是让我快速进入工作状态，熟悉我们这边的开发流程。

5. 第二个工作就是eSight对接三方SSO新服务的开发。

   SSO就是指单点登录，我们可以在多个应用系统中，只需用户登录一次就可以直接访问其他的应用系统，而不需要在进行登录认证。而CAS协议是实现SSO的一种业界解决方案。

6. 徐州新盛源他们有一个网管平台，实现了SSO Server，希望我们eSight能够对接，可以直接从他们的网管跳到我们eSight网管中。M+ 5G园区那别，也同样有相同的诉求。虽然CloudSop平台已经有SSO服务，但是它只能在平台之间对接，无法对接第三方SSO服务。平台那边对于SSO服务他们已经不在演进，因此需要我们eSight这边实现一个对接三方SSO的服务。

7. 原本平台的一个本地登录流程是：本地SSO服务端提供登录界面，本地SSO客户端到本地SSO服务端进行登录认证。现在我们需要让本地SSO客户端到三方的SSO服务端进行登录认证，平台提供了一个登录跳转的功能，因此我们可以新增了一个微服务SSOConfigService，它其他的桥接适配的作用，让本地的SSO客户端跳转到我们的服务中，完成本地SSO客户端到三方SSO服务端的连接，这个微服务承接了SSO配置功能，主要有：登录认证，票价验证，sesion创建与销毁和远端用户创建的工作。

8. 我们的SSO微服务主要涉及了三个部分，一个是CAS配置管理，它主要用于配置三方SSO的CAS信息，另外两个分别是单点登录和单点登出，他们使用CAS配置信息完成与三方SSO之间的单点登录和单点注销功能。工作量的话合计4.5人月。

9. 首先在CAS配置上，我们提供了一个配置界面，完成CAS信息的配置，包含了三方CAS的登录url,认证url,以及注销url。

10. 在单点登录的实现上，我们的处理流程是：当浏览器发送一个请求，首先判断该请求是不是登录请求，如果是，则判断本地是否配置了三方SSO服务，如果配置了对应服务，则判断请求中是否包含票据ticket，如果包含ticket则重定向到三方SSO服务进行票据验证，票据验证成功后会得到登录的用户名，然后我们会使用用户名取去平台获取用户信息，然后创建对应的session完成登录，当平台不存在该用户时，我们会创建一个远端用户用于登录。而如果请求没有ticket, 并且当前浏览器也没有登录时，我们会重定向请求到三方SSO服务完成登录认证。

11. 在单点登录的代码实现上，这里主要使用了J2EE的过滤器机制，实现了三个过滤器，登录认证过滤器，票据验证过滤器和单点注销过滤器，其中每个过滤器都要获取CAS配置信息，因此提取该公共方法到一个抽象类，考虑到票据验证流程的复杂性，使用了模板方法，让doFilter只关注具体的过滤流程，而具体业务逻辑的实现交给子类的钩子函数来完成。

12. 最后在单点注销的实现上，我们的处理流程是：

    第一种情况是本地注销：当浏览器发送一个注销请求，本地会完成注销任务，同时向三方SSO服务发送一个登出请求。

    第二种情况是从三方注销：在我们进行三方SSO登录时，三方SSO服务端在给我们颁发ticket的同时会注册我们的服务，当我们完成登录认证，会将session保存在sessionMap中。当三方SSO服务注销时，它会向我们的服务发送一个登录请求，该请求中还存在logoutRequest字段，我们根据这个字段从sessionMap中获取session，完成本地的注销。

    以上就是SSO服务的内容。

13. 我的最后一个需求时应用管理服务中的OS同步操作的重构工作。

    OS的同步操作，主要是获取纳管的OS的一些基本信息，不如版本好，内存，cpu,硬盘信息，以及进程，网卡等采集信息。

    该操作是以同步驱动器为实现，通过配置xml网元包完成对应采集指标的Motion定义，驱动器拿着motion到对应的SNMP或SSH执行器中采集信息，然后交给解析器对结果进行解析。

    目前代码在以SNMP协议为采集方式的win系统和esxi系统上，存在以下问题：

    首先是SNMP的oid节点写在常量类里，多达近30处，代码硬编码，不易修改，同时驱动器中发送SNMP请求时每次都要重复组装请求，代码冗余。

    另外大量解析方法写在驱动器中，驱动器的职责不单一，代码组织不友好。同时驱动的执行器只适配了SSH协议，还无法适配SNMP协议，导致网元包无法使用。

14. 针对以上问题，首先定义了SNMP的Motion对象，和SNMP的网元包结构，完成SNMP请求的oid节点的优雅插入，从而解决了问题1和问题2。

15. 针对解析方法混乱的问题，对解析方法在协议上进行分类，一个时SSH协议的解析方法在一个解析库中，另一个SNMP协议的解析方法在一个解析库中，通过自定义注解和反射将解析方法注册到解析工厂中，每次解析时只需从工厂中获取即可。从而解决了问题3.

16. 在执行器的SNMP的适配上，抽取了行为接口，不同的协议实现各自的逻辑，并通过简单工厂方法获取对应的执行器，从而解决了问题4.



